import { stripIndent } from "common-tags";
const dotPath = (...segments) => {
  return segments.flat().join(".");
};
const format = async (input, helpers) => {
  const formattedInput = await helpers.format(input, void 0, {
    includeNewlineAtEnd: false,
    prettier: {
      parser: "typescript",
      printWidth: 60
    }
  });
  return formattedInput.endsWith(";") ? formattedInput.substring(0, formattedInput.length - 1) : formattedInput;
};
const snippetRead = async (data, { helpers }) => {
  var _a, _b, _c;
  const { fieldPath, itemName } = data;
  const label = "React";
  switch (data.model.type) {
    case "StructuredText": {
      return [
        {
          label: `${label} (components)`,
          language: "tsx",
          code: await format(stripIndent`
							<PrismicRichText field={${dotPath(fieldPath)}} />
						`, helpers)
        },
        {
          label: `${label} (plain text)`,
          language: "tsx",
          code: await format(stripIndent`
							<PrismicText field={${dotPath(fieldPath)}} />
						`, helpers)
        }
      ];
    }
    case "Link": {
      const repeat = ((_a = data.model.config) == null ? void 0 : _a.repeat) ?? false;
      const allowText = ((_b = data.model.config) == null ? void 0 : _b.allowText) ?? false;
      const allowVariants = Boolean((_c = data.model.config) == null ? void 0 : _c.variants);
      const variant = (path2, prefix = "") => allowVariants ? `${prefix}className={${path2}.variant}` : "";
      const path = dotPath(fieldPath);
      let code;
      if (!repeat && !allowText) {
        code = await format(stripIndent`
					<PrismicNextLink field={${path}} ${variant(path)}>Link</PrismicNextLink>
				`, helpers);
      } else if (!repeat && allowText) {
        code = await format(stripIndent`
					<PrismicNextLink field={${path}} ${variant(path)}/>
				`, helpers);
      } else if (repeat && !allowText) {
        code = stripIndent`{${path}.map((link) => (
  <PrismicNextLink
    key={link.key}
    field={link}${variant("link", "\n    ")}>
      Link
  </PrismicNextLink>
))}`;
      } else if (repeat && allowText) {
        code = stripIndent`{${path}.map((link) => (
  <PrismicNextLink
    key={link.key}
    field={link}${variant("link", "\n    ")}
  />
))}`;
      } else {
        throw new Error("Invalid configuration.");
      }
      return {
        label,
        language: "tsx",
        code
      };
    }
    case "Image": {
      return {
        label,
        language: "tsx",
        code: await format(stripIndent`
						<PrismicNextImage field={${dotPath(fieldPath)}} />
					`, helpers)
      };
    }
    case "Table": {
      return {
        label,
        language: "tsx",
        code: await format(stripIndent`
						<PrismicTable field={${dotPath(fieldPath)}} />
					`, helpers)
      };
    }
    case "Group": {
      const code = stripIndent`
				{${dotPath(fieldPath)}.map((${itemName}) => (
				  // Render the ${itemName}
				))}
			`;
      return {
        label,
        language: "tsx",
        code
      };
    }
    case "Slices": {
      const code = await format(stripIndent`
					<SliceZone
					  slices={${dotPath(fieldPath)}}
					  components={components}
					/>
				`, helpers);
      return {
        label,
        language: "tsx",
        code
      };
    }
    case "GeoPoint": {
      const code = stripIndent`
				{${dotPath(fieldPath, "latitude")}}, {${dotPath(fieldPath, "longitude")}}
			`;
      return {
        label,
        language: "tsx",
        code
      };
    }
    case "Embed": {
      const code = await format(stripIndent`
					<div dangerouslySetInnerHTML={{ __html: ${dotPath(fieldPath, "html")} }} />
				`, helpers);
      return {
        label,
        language: "tsx",
        code
      };
    }
    default: {
      return {
        label,
        language: "tsx",
        // We cannot use `format` since this snippet contains invalid syntax.
        // Please ensure this snippet is manually formatted correctly.
        code: stripIndent`
					{${dotPath(fieldPath)}}
				`
      };
    }
  }
};
export {
  snippetRead
};
//# sourceMappingURL=snippet-read.js.map
